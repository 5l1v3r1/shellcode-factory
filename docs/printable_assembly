===========================
==== PRINTABLE OPCODES ====
====  (complete list)  ====
===========================

opcode (in hex)    | char |          mnemonic              | interesting
-------------------+------+--------------------------------+------------
20 </r>            | ' '  | andb <r/m8>,<r8>               | yes  
21 </r>            | '!'  | andl <r/m32>,<r32>             | yes  
22 </r>            | '"'  | andb <r8>,<r/m8>               | yes  
23 </r>            | '#'  | andl <r32>,<r/m32>             | yes  
24 <imm8>          | '$'  | andb %al,<imm8>                | yes  
25 <imm32>         | '%'  | andl %eax,<imm32>              | yes 
26                 | '&'  | es:   (Segment Override Prefix)|    
27                 | '''  | daa                            |    
28 </r>            | '('  | subb <r/m8>,<r8>               | yes  
29 </r>            | ')'  | subl <r/m32>,<r32>             | yes  
2a </r>            | '*'  | subb <r8>,<r/m8>               | yes  
2b </r>            | '+'  | subl <r32>,<r/m32>             | yes  
2c <imm8>          | ','  | subb %al,<imm8>                | yes  
2d <imm32>         | '-'  | subl %eax,<imm32>              | yes 
2e                 | '.'  | cs:   (Segment Override Prefix)|        
2f                 | '/'  | das                            |    
                   |      |                                |
30 </r>            | '0'  | xorb <r/m8>,<r8>               | YES
31 </r>            | '1'  | xorl <r/m32>,<r32>             | YES
32 </r>            | '2'  | xorb <r8>,<r/m8>               | YES
33 </r>            | '3'  | xorl <r32>,<r/m32>             | YES
34 <imm8>          | '4'  | xorb %al,<imm8>                | YES
35 <imm32>         | '5'  | xorl %eax,<imm32>              | YES
36                 | '6'  | ss:   (Segment Override Prefix)|
37                 | '7'  | aaa                            |
38 </r>            | '8'  | cmpb <r/m8>,<r8>               | YES
39 </r>            | '9'  | cmpl <r/m32>,<r32>             | YES
3A </r>            | ':'  | cmpb <r8>,<r/m8>    ~~~~~~     | yes 
3B </r>            | ';'  | cmpl <r32>,<r/m32>  ~~~~~~     | yes 
3C <imm8>          | '<'  | cmpb %al,<imm8>     ~~~~~~     | yes 
3D <imm32>         | '='  | cmpl %eax,<imm32>   ~~~~~~     | yes
3E                 | '>'  | ds:   (Segment Override Prefix)|    
3F                 | '?'  | aas      ~~~~~~                |    
                   |      |                                |
40                 | '@'  | incl %eax  ~~~~~~              | yes
41                 | 'A'  | incl %ecx                      | YES
42                 | 'B'  | incl %edx                      | YES
43                 | 'C'  | incl %ebx                      | YES
44                 | 'D'  | incl %esp                      | YES
45                 | 'E'  | incl %ebp                      | YES
46                 | 'F'  | incl %esi                      | YES
47                 | 'G'  | incl %edi                      | YES
48                 | 'H'  | decl %eax                      | YES
49                 | 'I'  | decl %ecx                      | YES
4A                 | 'J'  | decl %edx                      | YES
4B                 | 'K'  | decl %ebx                      | YES
4C                 | 'L'  | decl %esp                      | YES
4D                 | 'M'  | decl %ebp                      | YES
4E                 | 'N'  | decl %esi                      | YES
4F                 | 'O'  | decl %edi                      | YES
                   |      |                                |
50                 | 'P'  | pushl %eax                     | YES
51                 | 'Q'  | pushl %ecx                     | YES
52                 | 'R'  | pushl %edx                     | YES
53                 | 'S'  | pushl %ebx                     | YES
54                 | 'T'  | pushl %esp                     | YES
55                 | 'U'  | pushl %ebp                     | YES
56                 | 'V'  | pushl %esi                     | YES
57                 | 'W'  | pushl %edi                     | YES
58                 | 'X'  | popl %eax                      | YES
59                 | 'Y'  | popl %ecx                      | YES
5A                 | 'Z'  | popl %edx                      | YES
5B                 | '['  | popl %ebx ~~~~~~               | yes 
5C                 | '\'  | popl %esp ~~~~~~               | yes 
5D                 | ']'  | popl %ebp ~~~~~~               | yes 
5E                 | '^'  | popl %esi ~~~~~~               | yes 
5F                 | '_'  | popl %edi ~~~~~~               | yes 
                   |      |                                |
60                 | '`'  | pusha    ~~~~~~                | yes 
61                 | 'a'  | popa                           | YES
62 <...>           | 'b'  | bound <...>                    |
63 <...>           | 'c'  | arpl <...>                     |
64                 | 'd'  | fs:   (Segment Override Prefix)|
65                 | 'e'  | gs:   (Segment Override Prefix)|
66                 | 'f'  | o16:    (Operand Size Override)| YES
67                 | 'g'  | a16:    (Address Size Override)|
68 <imm32>         | 'h'  | pushl <imm32>                  | YES
69 <imm32>         | 'i'  | imull <imm32>                  | 
6A <imm8>          | 'j'  | pushb  <imm8>                  | YES
6B <imm8>          | 'k'  | imulb  <imm8>                  |
6C                 | 'l'  | insb  <imm8>                   |
6D                 | 'm'  | insl  <imm8>                   |
6E                 | 'n'  | outsb <imm8>                   |
6F                 | 'o'  | outsl <imm8>                   |
70 <disp8>         | 'p'  | jo  <disp8>                    | YES
71 <disp8>         | 'q'  | jno <disp8>                    | YES
72 <disp8>         | 'r'  | jb  <disp8>                    | YES
73 <disp8>         | 's'  | jae <disp8>                    | YES
74 <disp8>         | 't'  | je  <disp8>                    | YES
75 <disp8>         | 'u'  | jne <disp8>                    | YES
76 <disp8>         | 'v'  | jbe <disp8>                    | YES
77 <disp8>         | 'w'  | ja  <disp8>                    | YES
78 <disp8>         | 'x'  | js  <disp8>                    | YES
79 <disp8>         | 'y'  | jns <disp8>                    | YES
7A <disp8>         | 'z'  | jp  <disp8>                    | YES
7B <disp8>         | '}'  | jnp <disp8>                    | yes 
7C <disp8>         | '|'  | jl  <disp8>                    | yes 
7D <disp8>         | '}'  | jnl <disp8>                    | yes 
7E <disp8>         | '~'  | jle <disp8>                    | yes 


==========================
======  /r opcodes  ======
======     i.e.     ======
====== opcodes that ======
====== may interact ======
====== with memory: ======
==========================

They are multiple of 8 (aligned with 000 for the 3 last bits).
This alignment allows room for 3 extra bits:
- the "immediate_eax" bit,
- the direction bit,
- the size bit.

=== OPCODE's last 3 bits ===
> immediate_eax bit
  - 1 if src = immX and dst = %eax
  - 0 else
When this bit is 1, direction bit equals 0 (else it's a different opcode), and there is no mod r/m nor sib nor dispX bytes, just the ...10. opcode and the immX argument.
The rest of the explanation thus expects this bit to be 0.

> direction bit
  - 1 if r/m to r
  - 0 if r to r/m

> size bit (last bit)
  - 0 if r8
  - 1 if r32 / r16 (if r16, prefix op)

When not in "immediate_eax" mode, the opcode is followed by the ModR/M byte
(src and dst identified wihin a "single" byte)

=== Mod - (reg) - r/m ===
> mod (initial 2 bits)
   0 - 00 <-> disp0(%reg) i.e. (%reg) [m]
   1 - 01 <-> disp8(%reg) [m]
   2 - 10 <-> disp32(%reg) [m]
   3 - 11 <-> reg [r]

> (disp8 / disp32, when needed, come after the mod(reg)r/m byte)

> reg (middle 3 bits)
   0 -%eax - 000
   1 -%ecx - 001
   2 -%edx - 010
   3 -%ebx - 011
   4 -%esp - 100
   5 -%ebp - 101
   6 -%esi - 110
   7 -%edi - 111

> r/m (last 3 bits)
same as reg, except for:
 - r/m = 100 (<-> %esp) when mod != 11
     In that case, instead of dispX(%esp),
     we get SIB, i.e., dispX(base_reg, index_reg, 2 ^ scale)
     => to get dispX(%esp), you actually do dispX(%esp,%esp, 1)
 - r/m = 101 (<-> %ebp) when mod == 00
     In that case, instead of (%ebp),
     we get disp32 only (Intel syntax: [disp32] - GAS: disp32 (no dollar sign))
     => to get (%ebp), you actually do 0x00(%ebp) (i.e., <disp8> = 0x00)

It implies the usage of an additional byte, the SIB byte, placed after the mod(reg)r/m byte.

=== SIB byte ===
how to get dispX(base_reg, index_reg, 2 ^ scale) ?
> scale (initial 2 bits)
  0 - 00 -> 1
  1 - 01 -> 2
  2 - 10 -> 4
  3 - 11 -> 8

> index_reg (middle 3 bits)
Same as reg, except for index_reg = 100 (<-> %esp), which is forbidden 
(except in one case: dispX(%esp, %esp, 1) actually does dispX(%esp)
Thus, apart from that case (base_reg = 100, scale = 00), index cannot be 100).

> base_reg (last 3 bits)
Same as reg, except for base_reg = 101 (<-> %ebp) when mod = 00,
which leads to disp32(, index_reg, 2 ^ scale) instead of (%ebp, index_reg, 2 ^ scale)
=> to get (%ebp, index_reg, scale), you actually do 0x00(%ebp, index_reg, scale) (i.e., <disp8> = 0x00)


==== Order of bytes ====
'<>' stands for one byte
[<16-bit size prefix>] <opcode> [<mod-r/m> [<sib>] [<dispX>]] [<immX>]


==== Mod (reg) r/m byte array ====
           <r8>:| %al  | %cl  | %dl  | %bl  | %ah  | %ch  | %dh  | %bh
          <r32>:| %eax | %ecx | %edx | %ebx | %esp | %ebp | %esi | %edi
<r/m>           |      |      |      |      |      |      |      |
--:-------------+------+------+------+------+------+------+------+------
(mod=00)        |                           |      |      |      |
(%eax)          |            all            |20    |28    |30 '0'|38 '8'
(%ecx)          |            this           |21    |29    |31 '1'|39 '9'
(%edx)          |            area           |22    |2A    |32 '2'|3A
(%ebx)          |            is             |23    |2B    |33 '3'|3B
(<SIB>)         |            not            |24    |2C    |34 '4'|3C
(<disp32>)      |            printable      |25    |2D    |35 '5'|3D
(%esi)          |            !!             |26    |2E    |36 '6'|3E
(%edi)          |                           |27    |2F    |37 '7'|3F
----------------+------+------+------+------+------+------+------+------
(mod=01)        |      |      |      |      |      |      |      |
disp8(%eax)     |40    |48 'H'|50 'P'|58 'X'|60    |68 'h'|70 'p'|78 'x'
disp8(%ecx)     |41 'A'|49 'I'|51 'Q'|59 'Y'|61 'a'|69 'i'|71 'q'|79 'y'
disp8(%edx)     |42 'B'|4A 'J'|52 'R'|5A 'Z'|62 'b'|6A 'j'|72 'r'|7A 'z'
disp8(%ebx)     |43 'C'|4B 'K'|53 'S'|5B    |63 'c'|6B 'k'|73 's'|7B
disp8(<SIB>)    |44 'D'|4C 'L'|54 'T'|5C    |64 'd'|6C 'l'|74 't'|7C
disp8(%ebp)     |45 'E'|4D 'M'|55 'U'|5D    |65 'e'|6D 'm'|75 'u'|7D
disp8(%esi)     |46 'F'|4E 'N'|56 'V'|5E    |66 'f'|6E 'n'|76 'v'|7E
disp8(%edi)     |47 'G'|4F 'O'|57 'W'|5F    |67 'g'|6F 'o'|77 'w'|7F
----------------+------+------+------+------+------+------+------+------
(mod=10)        |80+
disp32(%reg)    |    ==> non-printable
----------------+------+------+------+------+------+------+------+------
(mod=11)        |C0+
r8 | r32        |    ==> non-printable


==== SIB byte array ====
    <base>:| %eax | %ecx | %edx | %ebx | %esp | %ebp | %esi | %edi
           |      |      |      |      |      | when |      |
           |      |      |      |      |      |MOD!=0|      |
<offset>   |      |      |      |      |      |else 0|      |
-----------+------+------+------+------+------+------+------+------
, %eax, 1  |         == all
, %ecx, 1  |                this area 
, %edx, 1  |                          is not
, %ebx, 1  |                                 printable ==
, %esp, 1  |(24 - Only allowed with base = %esp to mean (%esp) - 24)
, %ebp, 1  |28    |29    |2A    |2B    |2C    |2D    |2E    |2F
, %esi, 1  |30 '0'|31 '1'|32 '2'|33 '3'|34 '4'|35 '5'|36 '6'|37 '7'
, %edi, 1  |38 '8'|39 '9'|3A    |3B    |3C    |3D    |3E    |3F
-----------+------+------+------+------+------+------+------+------
, %eax, 2  |40    |41 'A'|42 'B'|43 'C'|44 'D'|45 'E'|46 'F'|47 'G'
, %ecx, 2  |48 'H'|49 'I'|4A 'J'|4B 'K'|4C 'L'|4D 'M'|4E 'N'|4F 'O'
, %edx, 2  |50 'P'|51 'Q'|52 'R'|53 'S'|54 'T'|55 'U'|56 'V'|57 'W'
, %ebx, 2  |58 'X'|59 'Y'|5A 'Z'|5B    |5C    |5D    |5E    |5F
, %esp, 2  |                   == FORBIDDEN ==
, %ebp, 2  |68 'h'|69 'i'|6A 'j'|6B 'k'|6C 'l'|6D 'm'|6E 'n'|6F 'o'
, %esi, 2  |70 'p'|71 'q'|72 'r'|73 's'|74 't'|75 'u'|76 'v'|77 'w'
, %edi, 2  |78 'x'|79 'y'|7A 'z'|7B    |7C    |7D    |7E    |7F
-----------+------+------+------+------+------+------+------+------
, %reg, 4  |80+ => non-printable
, %reg, 8  |C0+ => non-printable


========================
==== In other words ====
========================

0) The direction of the operation never changes its printability,
   and almost never changes its alphanumerical printability
   (the 'cmp' instr is the only one affected by the direction bit)

1) ModR/M - r->r operations are not printable: it has to be either r->m or m->r.
('r' stands for the access to/from a register, and 'm', to/from memory)

2) ModR/M - for all reg != %esp,
   - m = (%reg) is printable when r = %esp, %ebp, %esi or %edi
	     and even (alpha)numeric when r = %esi

3) ModR/M - for all reg != %esp,
   - m = disp8(%reg) is printable;
       	 	     	and even alphanumeric most of the time
   			(e.g., when r = %eax, %ecx, %edx, %ebp or %esi)

4) SIB - When m = dispX(base_reg, index_reg, scale_factor),
   - for scale_factor = 2,                   (and index_reg != %esp)
     m = disp8(base_reg, index_reg, 2) is
       	 - always printable and even
   	 - almost always alphanumeric
	   (when index_reg = %eax, %ecx, %edx, %ebp or %esi)
   - for scale_factor = 1,           	     (and index_reg != %esp)
     m = disp8(base_reg, index_reg, 1) is 
       	 - printable when index_reg = %ebp, %esi or %edi
     	 - (alpha)numeric when index_reg = %esi 
                       or when index_reg = %edi and base_reg = %eax or %ecx

5) ModR/M + SIB - when reg = %esp,
   - m = dispX(%esp) is not alphanumeric, but:
   - m = disp8(%esp) is always printable
   - m = (%esp) is only printable when r = %esp, %ebp, %esi or %edi

6) ModR/M + SIB - never printable cases:
   - m = disp32(...) is not printable.
   - m = dispX(base_reg, index_reg, 4) is not printable.
   - m = dispX(base_reg, index_reg, 8) is not printable.

Note: <immX> and <dispX> must also be chosen printable / alphanumeric


========================
==== ALPHANUMERICAL ====
====    OPCODES     ====
========================

opcode (in hex)    | char |          mnemonic              |
-------------------+------+--------------------------------+
30 </r>            | '0'  | xorb <r/m8>,<r8>               |
31 </r>            | '1'  | xorl <r/m32>,<r32>             |
32 </r>            | '2'  | xorb <r8>,<r/m8>               |
33 </r>            | '3'  | xorl <r32>,<r/m32>             |
34 <imm8>          | '4'  | xorb %al,<imm8>                |
35 <imm32>         | '5'  | xorl %eax,<imm32>              |

38 </r>            | '8'  | cmpb <r/m8>,<r8>               |
39 </r>            | '9'  | cmpl <r/m32>,<r32>             |

41                 | 'A'  | incl %ecx                      |
42                 | 'B'  | incl %edx                      |
43                 | 'C'  | incl %ebx                      |
44                 | 'D'  | incl %esp                      |
45                 | 'E'  | incl %ebp                      |
46                 | 'F'  | incl %esi                      |
47                 | 'G'  | incl %edi                      |

48                 | 'H'  | decl %eax                      |
49                 | 'I'  | decl %ecx                      |
4A                 | 'J'  | decl %edx                      |
4B                 | 'K'  | decl %ebx                      |
4C                 | 'L'  | decl %esp                      |
4D                 | 'M'  | decl %ebp                      |
4E                 | 'N'  | decl %esi                      |
4F                 | 'O'  | decl %edi                      |

50                 | 'P'  | pushl %eax                     |
51                 | 'Q'  | pushl %ecx                     |
52                 | 'R'  | pushl %edx                     |
53                 | 'S'  | pushl %ebx                     |
54                 | 'T'  | pushl %esp                     |
55                 | 'U'  | pushl %ebp                     |
56                 | 'V'  | pushl %esi                     |
57                 | 'W'  | pushl %edi                     |

58                 | 'X'  | popl %eax                      |
59                 | 'Y'  | popl %ecx                      |
5A                 | 'Z'  | popl %edx                      |

61                 | 'a'  | popa                           |

66                 | 'f'  | o16:    (Operand Size Override)|

68 <imm32>         | 'h'  | pushl <imm32>                  |
6A <imm8>          | 'j'  | pushb  <imm8>                  |

70 <disp8>         | 'p'  | jo  <disp8>                    |
71 <disp8>         | 'q'  | jno <disp8>                    |
72 <disp8>         | 'r'  | jb  <disp8>                    |
73 <disp8>         | 's'  | jae <disp8>                    |
74 <disp8>         | 't'  | je  <disp8>                    |
75 <disp8>         | 'u'  | jne <disp8>                    |
76 <disp8>         | 'v'  | jbe <disp8>                    |
77 <disp8>         | 'w'  | ja  <disp8>                    |
78 <disp8>         | 'x'  | js  <disp8>                    |
79 <disp8>         | 'y'  | jns <disp8>                    |
7A <disp8>         | 'z'  | jp  <disp8>                    |


===============================
====   PRINTABLE OPCODES   ====
==== (non alpha-numerical) ====
===============================

opcode (in hex)    | char |          mnemonic              |
-------------------+------+--------------------------------+
20 </r>            | ' '  | andb <r/m8>,<r8>               |
21 </r>            | '!'  | andl <r/m32>,<r32>             |
22 </r>            | '"'  | andb <r8>,<r/m8>               |
23 </r>            | '#'  | andl <r32>,<r/m32>             |
24 <imm8>          | '$'  | andb %al,<imm8>                |
25 <imm32>         | '%'  | andl %eax,<imm32>              |

28 </r>            | '('  | subb <r/m8>,<r8>               |
29 </r>            | ')'  | subl <r/m32>,<r32>             |
2a </r>            | '*'  | subb <r8>,<r/m8>               |
2b </r>            | '+'  | subl <r32>,<r/m32>             |
2c <imm8>          | ','  | subb %al,<imm8>                |
2d <imm32>         | '-'  | subl %eax,<imm32>              |

3A </r>            | ':'  | cmpb <r8>,<r/m8>    ~~~~~~     |
3B </r>            | ';'  | cmpl <r32>,<r/m32>  ~~~~~~     |
3C <imm8>          | '<'  | cmpb %al,<imm8>     ~~~~~~     |
3D <imm32>         | '='  | cmpl %eax,<imm32>   ~~~~~~     |

40                 | '@'  | incl %eax  ~~~~~~              |

5B                 | '['  | popl %ebx ~~~~~~               |
5C                 | '\'  | popl %esp ~~~~~~               |
5D                 | ']'  | popl %ebp ~~~~~~               |
5E                 | '^'  | popl %esi ~~~~~~               |
5F                 | '_'  | popl %edi ~~~~~~               |

60                 | '`'  | pusha    ~~~~~~                |

7B <disp8>         | '}'  | jnp <disp8>                    |
7C <disp8>         | '|'  | jl  <disp8>                    |
7D <disp8>         | '}'  | jnl <disp8>                    |
7E <disp8>         | '~'  | jle <disp8>                    |


========================
====    Examples    ====
==== (alphanumeric) ====
========================

1) "pmov" ('mov src, dst' equivalent):
.macro pmov src, dst
       push \src
       popl \dst
.endm
# Always printable
# src can be any register or an <imm32> or an <imm8> when -0x81 < imm8 < 0x80
# Alphanumeric only when dst = %eax, %ebx or %edx
# Length: 2 bytes (6 when src = <imm32>)

2) "zero_eax"
.macro zero_eax
       pmov $0x41414141, %eax
       xorl  $0x41414141, %eax
.endm
# Length: 11 bytes, so it is advisable to store the 0 into another registry
# (to get it with 2 bytes instead)

3) "rep_add" ('add n, reg' by iterating inc / dec)
.macro repadd n, reg
.if \n < 0
	dec \reg
	rep_add "(\n + 1)", \reg
.endif
.if \n > 0
	inc \reg
	rep_add "(\n - 1)", \reg
.endif
.endm
# /!\ inc %eax is not alphanumeric /!\
# Cannot be used with 8-bit registers
# Length:	n bytes for a 32-bit register
# and		2 * n bytes for a 16-bit register


4) "set_regs" (changes (up to) all the registries (except %esp))
.macro set_regs eax=%eax, ecx=%ecx, edx=%edx, ebx=%ebx, ebp=%ebp, esi=%esi, edi=%edi, buried=%eax
	push \eax
	push \ecx
	push \edx
	push \ebx
	push \buried		# there is no 'popl %esp' in popa
	push \ebp
	push \esi
	push \edi
	popa
.endm
# Length: #imm8 + 4 * #imm32 + 9 bytes
# 'buried' may be used to "bury" something in the stack (advanced)


5) "nopnop" (when you have "nothing" better to do)
.macro nopnop
       incl %edi
       decl %edi
.endm
# nopnop = "GO"

6) "pop_eip" (right when coming from a 'ret' instruction)
.macro pop_eip reg
	rep_add -4, %esp	# pushl %eip
	popl \reg
.endm
# Length: 5 bytes

7) "init_regs" (partial popa example)
.macro init_regs
	rep_add -4, %esp	# popa-3: %ebp = %eip
	zero_eax
	decl %eax
	pushl %eax		# popa-2: %esi = -1
	xorb $0x33, %al
	pushl %eax		# popa-1: %edi = -0x34
	popa

	pmov %esi, %eax
	xorl $0x30303030, %eax
	set_regs eax=%esi, ebx=%esi, ecx=%ebp, edx=%esi, esi=%edi, ebp=%eax
	incl %edx
.endm
# %eax = -1
# %ebx = -1
# %ecx ~ %eip
# %edx = 0
# %esi = -0x34
# %edi = -0x34
# %ebp = 0xcdcdcdcd = 0xffffffff ^ 0x30303030

8) Access around the top of the stack
# When %esi = -0x34,
# 0x34(%esp, %esi) ==     (%esp)	# top of the stack
# 0x30(%esp, %esi) == -0x4(%esp)	# next value
# 0x38(%esp, %esi) ==  0x4(%esp)
# Requires %esi = -0x34
# Length: |<SIB> <0x34>| = 2 bytes

9) Modifying %esp (assuming %esi = -0x34)
.macro popl_esp aux_reg=%eax
	pmov %esp, \aux_reg		# aux_reg := %esp
	xorl 0x34(%esp, %esi), \aux_reg	# aux_reg := X ^ %esp
	pushl \aux_reg
	popl \aux_reg
	xorl 0x30(%esp, %esi), %esp	# %esp := aux_reg ^ %esp = X
.endm
# /!\ Corrupts aux_reg /!\
# Length: 12 bytes
