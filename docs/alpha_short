----| The usable instructions


Before beginning to think about particular techniques, let's first have a
look at the IA32 instructions that will be interesting for us.

First of all, some conventions (from Intel references) that we'll use in
our summary arrays:
 <r8>          : indicates a byte register.
 <r32>         : indicates a doubleword register.
 <r/m8>        : indicates a byte register or a byte from memory (through
                 a pointer).
 <r/m32>       : indicates a doubleword register or a doubleword from
                 memory (through a pointer).
 </r>          : indicates that the instruction byte is followed of
                 possibly several operand bytes. One of those bytes, the
                 "ModR/M byte", permits us to specify the used addressing
                 form,with the help of 3 bit fields.

                     ModR/M byte:                 
                     
                    7 6 5 4 3 2 1 0 
                   +---+-----+-----+
                   |mod|  r  | r/m |
                   +---+-----+-----+
                   
                 In this case, the </r> indicates us the ModR/M byte will
                 contain a register operand and a register or memory
                 operand.
 <imm8>        : indicates an immediate byte value.
 <imm32>       : indicates an immediate doubleword value.
 <disp8>       : indicates a signed 8 bits displacement.
 <disp32>      : indicates a signed 32 bits displacement.
 <...>         : indicates the instruction possibly need some operands
                 (eventually encoded on several operand bytes).


ALPHANUMERIC OPCODES:

Now, let's remember all instructions with alphanumeric opcodes:

hexadecimal opcode | char | instruction                    | interesting
-------------------+------+--------------------------------+------------
30 </r>            | '0'  | xor <r/m8>,<r8>                | YES
31 </r>            | '1'  | xor <r/m32>,<r32>              | YES
32 </r>            | '2'  | xor <r8>,<r/m8>                | YES
33 </r>            | '3'  | xor <r32>,<r/m32>              | YES
34 <imm8>          | '4'  | xor al,<imm8>                  | YES
35 <imm32>         | '5'  | xor eax,<imm32>                | YES
36                 | '6'  | ss:   (Segment Override Prefix)|
37                 | '7'  | aaa                            |
38 </r>            | '8'  | cmp <r/m8>,<r8>                | YES
39 </r>            | '9'  | cmp <r/m32>,<r32>              | YES
                   |      |                                |
41                 | 'A'  | inc ecx                        | YES
42                 | 'B'  | inc edx                        | YES
43                 | 'C'  | inc ebx                        | YES
44                 | 'D'  | inc esp                        | YES
45                 | 'E'  | inc ebp                        | YES
46                 | 'F'  | inc esi                        | YES
47                 | 'G'  | inc edi                        | YES
48                 | 'H'  | dec eax                        | YES
49                 | 'I'  | dec ecx                        | YES
4A                 | 'J'  | dec edx                        | YES
4B                 | 'K'  | dec ebx                        | YES
4C                 | 'L'  | dec esp                        | YES
4D                 | 'M'  | dec ebp                        | YES
4E                 | 'N'  | dec esi                        | YES
4F                 | 'O'  | dec edi                        | YES
50                 | 'P'  | push eax                       | YES
51                 | 'Q'  | push ecx                       | YES
52                 | 'R'  | push edx                       | YES
53                 | 'S'  | push ebx                       | YES
54                 | 'T'  | push esp                       | YES
55                 | 'U'  | push ebp                       | YES
56                 | 'V'  | push esi                       | YES
57                 | 'W'  | push edi                       | YES
58                 | 'X'  | pop eax                        | YES
59                 | 'Y'  | pop ecx                        | YES
5A                 | 'Z'  | pop edx                        | YES
                   |      |                                |
61                 | 'a'  | popa                           | YES
62 <...>           | 'b'  | bound <...>                    |
63 <...>           | 'c'  | arpl <...>                     |
64                 | 'd'  | fs:   (Segment Override Prefix)|
65                 | 'e'  | gs:   (Segment Override Prefix)|
66                 | 'f'  | o16:    (Operand Size Override)| YES
67                 | 'g'  | a16:    (Address Size Override)|
68 <imm32>         | 'h'  | push <imm32>                   | YES
69 <...>           | 'i'  | imul <...>                     | 
6A <imm8>          | 'j'  | push <imm8>                    | YES
6B <...>           | 'k'  | imul <...>                     |
6C <...>           | 'l'  | insb <...>                     |
6D <...>           | 'm'  | insd <...>                     |
6E <...>           | 'n'  | outsb <...>                    |
6F <...>           | 'o'  | outsd <...>                    |
70 <disp8>         | 'p'  | jo <disp8>                     | YES
71 <disp8>         | 'q'  | jno <disp8>                    | YES
72 <disp8>         | 'r'  | jb <disp8>                     | YES
73 <disp8>         | 's'  | jae <disp8>                    | YES
74 <disp8>         | 't'  | je <disp8>                     | YES
75 <disp8>         | 'u'  | jne <disp8>                    | YES
76 <disp8>         | 'v'  | jbe <disp8>                    | YES
77 <disp8>         | 'w'  | ja <disp8>                     | YES
78 <disp8>         | 'x'  | js <disp8>                     | YES
79 <disp8>         | 'y'  | jns <disp8>                    | YES
7A <disp8>         | 'z'  | jp <disp8>                     | YES

What can we directly deduct of all this?

- NO "MOV" INSTRUCTIONS:
 => we need to find another way to manipulate our data.
- NO INTERESTING ARITHMETIC INSTRUCTIONS ("ADD","SUB",...):
 => we can only use DEC and INC.
 => we can't use INC with the EAX register.
- THE "XOR" INSTRUCTION:
 => we can use XOR with bytes and doublewords.
 => very interesting for basic crypto stuff. 
- "PUSH"/"POP"/"POPAD" INSTRUCTIONS:
 => we can push bytes and doublewords directly on the stack.
 => we can only use POP with the EAX,ECX and EDX registers.
 => it seems we're going to play again with the stack.
- THE "O16" OPERAND SIZE OVERRIDE:
 => we can also achieve 16 bits manipulations with this instruction
    prefix.
- "JMP" AND "CMP" INSTRUCTIONS:
 => we can realize some comparisons.
 => we can't directly use constant values with CMP.


Besides, Don't forget that operands of these instructions (</r>, <imm8>,
<imm32>, <disp8> and <disp32>) must also remain alphanumeric. It may
make our task once again more complicated...


THE "ModR/M" BYTE:

For example, let's observe the effect of this supplementary constraint on
the ModR/M byte (</r>), particularly for XOR and CMP.
In the next array, we'll find all the possible values for this ModR/M
byte, and their interpretation as <r8>/<r32> (first row) and <r/m> (first
column) operands.

           <r8>:|  al  |  cl  |  dl  |  bl  |  ah  |  ch  |  dh  |  bh 
          <r32>:| eax  | ecx  | edx  | ebx  | esp  | ebp  | esi  | edi
<r/m>           |      |      |      |      |      |      |      |
--:-------------+------+------+------+------+------+------+------+------
(mod=00)        |      |      |      |      |      |      |      |
[eax]           |00    |08    |10    |18    |20    |28    |30 '0'|38 '8'
[ecx]           |01    |09    |11    |19    |21    |29    |31 '1'|39 '9'
[edx]           |02    |0A    |12    |1A    |22    |2A    |32 '2'|3A
[ebx]           |03    |0B    |13    |1B    |23    |2B    |33 '3'|3B
[<SIB>]         |04    |0C    |14    |1C    |24    |2C    |34 '4'|3C
[<disp32>]      |05    |0D    |15    |1D    |25    |2D    |35 '5'|3D
[esi]           |06    |0E    |16    |1E    |26    |2E    |36 '6'|3E
[edi]           |07    |0F    |17    |1F    |27    |2F    |37 '7'|3F
----------------+------+------+------+------+------+------+------+------
(mod=01)        |      |      |      |      |      |      |      |
[eax+<disp8>]   |40    |48 'H'|50 'P'|58 'X'|60    |68 'h'|70 'p'|78 'x'
[ecx+<disp8>]   |41 'A'|49 'I'|51 'Q'|59 'Y'|61 'a'|69 'i'|71 'q'|79 'y'
[edx+<disp8>]   |42 'B'|4A 'J'|52 'R'|5A 'Z'|62 'b'|6A 'j'|72 'r'|7A 'z'
[ebx+<disp8>]   |43 'C'|4B 'K'|53 'S'|5B    |63 'c'|6B 'k'|73 's'|7B
[<SIB>+<disp8>] |44 'D'|4C 'L'|54 'T'|5C    |64 'd'|6C 'l'|74 't'|7C
[ebp+<disp8>]   |45 'E'|4D 'M'|55 'U'|5D    |65 'e'|6D 'm'|75 'u'|7D
[esi+<disp8>]   |46 'F'|4E 'N'|56 'V'|5E    |66 'f'|6E 'n'|76 'v'|7E
[edi+<disp8>]   |47 'G'|4F 'O'|57 'W'|5F    |67 'g'|6F 'o'|77 'w'|7F
----------------+------+------+------+------+------+------+------+------
(mod=10)        |      |      |      |      |      |      |      |
[eax+<disp32>]  |80    |88    |90    |98    |A0    |A8    |B0    |B8
[ecx+<disp32>]  |81    |89    |91    |99    |A1    |A9    |B1    |B9
[edx+<disp32>]  |82    |8A    |92    |9A    |A2    |AA    |B2    |BA
[ebx+<disp32>]  |83    |8B    |93    |9B    |A3    |AB    |B3    |BB
[<SIB>+<disp32>]|84    |8C    |94    |9C    |A4    |AC    |B4    |BC
[ebp+<disp32>]  |85    |8D    |95    |9D    |A5    |AD    |B5    |BD
[esi+<disp32>]  |86    |8E    |96    |9E    |A6    |AE    |B6    |BE
[edi+<disp32>]  |87    |8F    |97    |9F    |A7    |AF    |B7    |BF
---+------------+------+------+------+------+------+------+------+------
(mod=11)        |      |      |      |      |      |      |      |
al | eax        |C0    |C8    |D0    |D8    |E0    |E8    |F0    |F8
cl | ecx        |C1    |C9    |D1    |D9    |E1    |E9    |F1    |F9
dl | edx        |C2    |CA    |D2    |DA    |E2    |EA    |F2    |FA
bl | ebx        |C3    |CB    |D3    |DB    |E3    |EB    |F3    |FB
ah | esp        |C4    |CC    |D4    |DC    |E4    |EC    |F4    |FC
ch | ebp        |C5    |CD    |D5    |DD    |E5    |ED    |F5    |FD
dh | esi        |C6    |CE    |D6    |DE    |E6    |EE    |F6    |FE
bh | edi        |C7    |CF    |D7    |DF    |E7    |EF    |F7    |FF

What can we deduct this time for XOR and CMP?

- SOME "xor [<r32>],dh" AND "xor [<r32>],bh" INSTRUCTIONS.
- THE "xor [<disp32>],dh" INSTRUCTION.
- SOME "xor [<r32>+<disp8>],<r8>" INSTRUCTIONS.
- NO "xor <r8>,<r8>" INSTRUCTIONS.

- SOME "xor [<r32>],esi" AND "xor [<r32>],edi" INSTRUCTIONS.
- THE "xor [<disp32>],esi" INSTRUCTION.
- SOME "xor [<r32>+<disp8>],<r32>" INSTRUCTIONS.
- NO "xor <r32>,<r32>" INSTRUCTIONS.

- SOME "xor dh,[<r32>]" AND "xor bh,[<r32>]" INSTRUCTIONS.
- THE "xor dh,[<disp32>]" INSTRUCTION.
- SOME "xor <r8>,[<r32>+<disp8>]" INSTRUCTIONS.

- SOME "xor esi,[<r32>]" AND "xor edi,[<r32>]" INSTRUCTIONS.
- THE "xor esi,[<disp32>]" INSTRUCTION.
- SOME "xor <r32>,[<r32>+<disp8>]" INSTRUCTIONS.

- SOME "cmp [<r32>],dh" AND "cmp [<r32>],bh" INSTRUCTIONS.
- THE "cmp [<disp32>],dh" INSTRUCTION.
- SOME "cmp [<r32>+<disp8>],<r8>" INSTRUCTIONS.
- NO "cmp <r8>,<r8>" INSTRUCTIONS.

- SOME "cmp [<r32>],esi" AND "cmp [<r32>],edi" INSTRUCTIONS.
- THE "cmp [<disp32>],esi" INSTRUCTION.
- SOME "cmp [<r32>+<disp8>],<r32>" INSTRUCTIONS.
- NO "cmp <r32>,<r32>" INSTRUCTIONS.


THE "SIB" BYTE:

To be complete, we must also analyze possibilities offered by the Scale
Index Base byte ("<SIB>" in our last array). This SIB byte allows us to
create addresses having the following form:
 <SIB> = <base>+(2^<scale>)*<index>
Where:
 <base>  : indicate a base register.
 <index> : indicate an index register.
 <scale> : indicate a scale factor for the index register.

Here are the different bit fields of this byte:

  7 6 5 4 3 2 1 0 
 +---+-----+-----+
 |sc.|index|base |
 +---+-----+-----+

Let's have a look at this last array:

    <base>:| eax  | ecx  | edx  | ebx  | esp  | ebp  | esi  | edi
           |      |      |      |      |      | (if  |      |
(2^<scale>)|      |      |      |      |      |  MOD |      |
*<index>   |      |      |      |      |      | !=00)|      |
----:------+------+------+------+------+------+------+------+------
eax        |00    |01    |02    |03    |04    |05    |06    |07
ecx        |08    |09    |0A    |0B    |0C    |0D    |0E    |0F
edx        |10    |11    |12    |13    |14    |15    |16    |17
ebx        |18    |19    |1A    |1B    |1C    |1D    |1E    |1F
0          |20    |21    |22    |23    |24    |25    |26    |27
ebp        |28    |29    |2A    |2B    |2C    |2D    |2E    |2F
esi        |30 '0'|31 '1'|32 '2'|33 '3'|34 '4'|35 '5'|36 '6'|37 '7'
edi        |38 '8'|39 '9'|3A    |3B    |3C    |3D    |3E    |3F
-----------+------+------+------+------+------+------+------+------
2*eax      |40    |41 'A'|42 'B'|43 'C'|44 'D'|45 'E'|46 'F'|47 'G'
2*ecx      |48 'H'|49 'I'|4A 'J'|4B 'K'|4C 'L'|4D 'M'|4E 'N'|4F 'O'
2*edx      |50 'P'|51 'Q'|52 'R'|53 'S'|54 'T'|55 'U'|56 'V'|57 'W'
2*ebx      |58 'X'|59 'Y'|5A 'Z'|5B    |5C    |5D    |5E    |5F
0          |60    |61 'a'|62 'b'|63 'c'|64 'd'|65 'e'|66 'f'|67 'g'
2*ebp      |68 'h'|69 'i'|6A 'j'|6B 'k'|6C 'l'|6D 'm'|6E 'n'|6F 'o'
2*esi      |70 'p'|71 'q'|72 'r'|73 's'|74 't'|75 'u'|76 'v'|77 'w'
2*edi      |78 'x'|79 'y'|7A 'z'|7B    |7C    |7D    |7E    |7F
-----------+------+------+------+------+------+------+------+------
4*eax      |80    |81    |82    |83    |84    |85    |86    |87
4*ecx      |88    |89    |8A    |8B    |8C    |8D    |8E    |8F
4*edx      |90    |91    |92    |93    |94    |95    |96    |97
4*ebx      |98    |99    |9A    |9B    |9C    |9D    |9E    |9F
0          |A0    |A1    |A2    |A3    |A4    |A5    |A6    |A7
4*ebp      |A8    |A9    |AA    |AB    |AC    |AD    |AE    |AF
4*esi      |B0    |B1    |B2    |B3    |B4    |B5    |B6    |B7
4*edi      |B8    |B9    |BA    |BB    |BC    |BD    |BE    |BF
-----------+------+------+------+------+------+------+------+------
8*eax      |C0    |C1    |C2    |C3    |C4    |C5    |C6    |C7
8*ecx      |C8    |C9    |CA    |CB    |CC    |CD    |CE    |CF
8*edx      |D0    |D1    |D2    |D3    |D4    |D5    |D6    |D7
8*ebx      |D8    |D9    |DA    |DB    |DC    |DD    |DE    |DF
0          |E0    |E1    |E2    |E3    |E4    |E5    |E6    |E7
8*ebp      |E8    |E9    |EA    |EB    |EC    |ED    |EE    |EF
8*esi      |F0    |F1    |F2    |F3    |F4    |F5    |F6    |F7
8*edi      |F8    |F9    |FA    |FB    |FC    |FD    |FE    |FF
-----------+------+------+------+------+------+------+------+------
(if <base> |
   ==ebp   | => <SIB> = <disp32>+(2^<scale>)*<index>
and MOD==0)|
-----------+-------------------------------------------------------

What can we deduct of this last array?
- SOME "<r32>+esi" SIB ADDRESSES.
- SOME "<r32>+2*<r32>" SIB ADDRESSES.
- NO "<r32>+4*<r32>" OR "<r32>+8*<r32>" SIB ADDRESSES.


Also remember that the usual bytes order for a full instruction with
possibly ModR/M, SIB byte and disp8/disp32 is:
 <opcode> [Mode R/M byte] [<SIB>] [<disp8>/<disp32>]


THE "XOR" INSTRUCTION:

We notice that we have some possibilities for the XOR instruction. Let's
remember briefly all possible logical combinations:

a | b | a XOR b (=c)
--+---+-------------
0 | 0 |    0
0 | 1 |    1
1 | 0 |    1
1 | 1 |    0

What can we deduct of this?
-  a XOR a = 0
 => we can easily initialize registers to 0.
-  0 XOR b = b
 => we can easily load values in registers containing 0.
-  1 XOR b = NOT b
 => we can easily invert values using registers containing 0xFFFFFFFF.
-  a XOR b = c
   b XOR c = a
   a XOR c = b
 => we can easily find a byte's XOR complement.



----| Classic manipulations


Now, we are going to see various methods permitting to achieve a maximum
of usual low level manipulations from the authorized instructions listed
above.


INITIALIZING REGISTERS WITH PARTICULAR VALUES:

First of all, let's think about a method allowing us to initialize some
very useful particular values in our registers, like 0 or 0xFFFFFFFF
(see alphanumeric_initialize_registers() in asc.c).
For example:

 push 'aaaa'                      ; 'a' 'a' 'a' 'a'
 pop eax                          ;EAX now contains 'aaaa'.
 xor eax,'aaaa'                   ;EAX now contains 0.

 dec eax                          ;EAX now contains 0xFFFFFFFF.

We are going to memorize those special values in particular registers, to
be able to use them easily.


INITIALIZING ALL REGISTERS:

At the beginning of our shellcode, we will need to initialize several
registers with values that we will probably use later.
Don't forget that we can't use POP with all registers (only EAX,ECX and
EDX) We will then use POPAD. For example, if we suppose EAX contain 0 and
ECX contain 'aaaa', we can initialize all our registers easily:

 push eax                         ;EAX will contain 0.
 push ecx                         ;no change to ECX ('aaaa').
 push esp                         ;EDX will contain ESP after POPAD.
 push eax                         ;EBX will contain 0.
 push esp                         ;no change to ESP.
 push ebp                         ;no change to EBP.
 push ecx                         ;ESI will contain 'aaaa' after POPAD.
 dec eax                          ;EAX will contain 0xFFFFFFFF.
 push eax                         ;EDI will contain 0xFFFFFFFF.
 popad                            ;we get all values from the stack.


COPYING FROM REGISTERS TO REGISTERS:

Using POPAD, we can also copy data from any register to any register, if
we can't PUSH/POP directly. For example, copying EAX to EBX:

 push eax                         ;no change.
 push ecx                         ;no change.
 push edx                         ;no change.
 push eax                         ;EBX will contain EAX after POPAD.
 push eax                         ;no change (ESP not "poped").
 push ebp                         ;no change.
 push esi                         ;no change.
 push edi                         ;no change.
 popad

Let's note that the ESP's value is changed before the PUSH since we have 2
PUSH preceding it, but POPAD POP all registers except ESP from the stack.


SIMULATING A "NOT" INSTRUCTION:

By using XOR, we can easily realize a classical NOT instruction. Suppose
EAX contains the value we want to invert, and EDI contains 0xFFFFFFFF:

 push eax                         ;we push the value we want to invert.
 push esp                         ;we push the offset of the value we
                                  ; pushed on the stack.
 pop ecx                          ;ECX now contains this offset.
 xor [ecx],edi                    ;we invert the value.
 pop eax                          ;we get it back in EAX.


READING BYTES FROM MEMORY TO A REGISTER:

Once again, by using XOR and the 0 value (here in EAX), we can read an
arbitrary byte into DH:

 push eax                         ;we push 0 on the stack.
 pop edx                          ;we get it back in ECX (DH is now 0).
 xor dh,[esi]                     ;we read our byte using [esi] as source
                                  ;address.                              

We can also read values not far from [esp] on the stack, by using DEC/INC
on ESP, and then using a classical POP.


WRITING ALPHANUMERIC BYTES TO MEMORY:

If we need a small place to write bytes, we can easily use PUSH and write
our bytes by decreasing memory addresses and playing with INC on ESP.

 push 'cdef'                      ;                 'c' 'd' 'e' 'f'
 push 'XXab'                      ; 'X' 'X' 'a' 'b' 'c' 'd' 'e' 'f'
 inc esp                          ;     'X' 'a' 'b' 'c' 'd' 'e' 'f'
 inc esp                          ;         'a' 'b' 'c' 'd' 'e' 'f'

Now, ESP points at a "abcdef" string written on the stack...
We can also use the 016 instruction prefix to directly push a 16 bits
value:

 push 'cdef'                      ;         'c' 'd' 'e' 'f'
 push 'ab'                        ; 'a' 'b' 'c' 'd' 'e' 'f'

